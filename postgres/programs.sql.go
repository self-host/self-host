// Code generated by sqlc. DO NOT EDIT.
// source: programs.sql

package postgresql

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createCodeRevision = `-- name: CreateCodeRevision :one
INSERT INTO program_code_revisions (program_uuid, revision, created_by, code, checksum)
VALUES (
	$1,
	COALESCE((
		SELECT MAX(pcr.revision) + 1
		FROM program_code_revisions AS pcr
		WHERE pcr.program_uuid = $1
	), 0)::INTEGER,
	$2,
	$3,
	sha256($3)
) RETURNING
	program_uuid,
	revision,
	created,
	created_by,
	signed,
	signed_by,
	encode(checksum, 'hex') AS checksum
`

type CreateCodeRevisionParams struct {
	ProgramUuid uuid.UUID
	CreatedBy   uuid.UUID
	Code        []byte
}

type CreateCodeRevisionRow struct {
	ProgramUuid uuid.UUID
	Revision    int32
	Created     time.Time
	CreatedBy   uuid.UUID
	Signed      sql.NullTime
	SignedBy    uuid.UUID
	Checksum    string
}

func (q *Queries) CreateCodeRevision(ctx context.Context, arg CreateCodeRevisionParams) (CreateCodeRevisionRow, error) {
	row := q.queryRow(ctx, q.createCodeRevisionStmt, createCodeRevision, arg.ProgramUuid, arg.CreatedBy, arg.Code)
	var i CreateCodeRevisionRow
	err := row.Scan(
		&i.ProgramUuid,
		&i.Revision,
		&i.Created,
		&i.CreatedBy,
		&i.Signed,
		&i.SignedBy,
		&i.Checksum,
	)
	return i, err
}

const createProgram = `-- name: CreateProgram :one
WITH p AS (
	INSERT INTO programs (name, type, state, schedule, deadline, language, tags)
	VALUES (
		$1,
		$2,
		$3,
		$4,
		$5,
		$6,
		$7
	) RETURNING uuid, name, type, state, schedule, deadline, language, tags
), grp AS (
	SELECT groups.uuid
	FROM groups, user_groups
	WHERE user_groups.group_uuid = groups.uuid
	AND user_groups.user_uuid = $8
	AND groups.uuid = (
		SELECT users.uuid
		FROM users
		WHERE users.name = groups.name
	)
	LIMIT 1
), grp_policies AS (
	INSERT INTO group_policies(group_uuid, priority, effect, action, resource)
	VALUES (
		(SELECT uuid FROM grp), 0, 'allow', 'create','programs/'||(SELECT uuid FROM p)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'read','programs/'||(SELECT uuid FROM p)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'update','programs/'||(SELECT uuid FROM p)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'delete','programs/'||(SELECT uuid FROM p)||'/%'
	)
)
SELECT uuid, name, type, state, schedule, deadline, language, tags
FROM p LIMIT 1
`

type CreateProgramParams struct {
	Name      string
	Type      string
	State     string
	Schedule  string
	Deadline  int32
	Language  string
	Tags      []string
	CreatedBy uuid.UUID
}

type CreateProgramRow struct {
	Uuid     uuid.UUID
	Name     string
	Type     string
	State    string
	Schedule string
	Deadline int32
	Language string
	Tags     []string
}

func (q *Queries) CreateProgram(ctx context.Context, arg CreateProgramParams) (CreateProgramRow, error) {
	row := q.queryRow(ctx, q.createProgramStmt, createProgram,
		arg.Name,
		arg.Type,
		arg.State,
		arg.Schedule,
		arg.Deadline,
		arg.Language,
		pq.Array(arg.Tags),
		arg.CreatedBy,
	)
	var i CreateProgramRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Type,
		&i.State,
		&i.Schedule,
		&i.Deadline,
		&i.Language,
		pq.Array(&i.Tags),
	)
	return i, err
}

const deleteProgram = `-- name: DeleteProgram :execrows
DELETE FROM programs
WHERE programs.uuid = $1
`

func (q *Queries) DeleteProgram(ctx context.Context, uuid uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteProgramStmt, deleteProgram, uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProgramCodeRevision = `-- name: DeleteProgramCodeRevision :execrows
DELETE FROM program_code_revisions
WHERE program_uuid = $1
AND revision = $2
`

type DeleteProgramCodeRevisionParams struct {
	ProgramUuid uuid.UUID
	Revision    int32
}

func (q *Queries) DeleteProgramCodeRevision(ctx context.Context, arg DeleteProgramCodeRevisionParams) (int64, error) {
	result, err := q.exec(ctx, q.deleteProgramCodeRevisionStmt, deleteProgramCodeRevision, arg.ProgramUuid, arg.Revision)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const existsProgram = `-- name: ExistsProgram :one
SELECT COUNT(*) AS count
FROM programs
WHERE programs.uuid = $1
`

func (q *Queries) ExistsProgram(ctx context.Context, uuid uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.existsProgramStmt, existsProgram, uuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findAllModules = `-- name: FindAllModules :many
SELECT
	programs.name,
	pcr.program_uuid,
        programs.type,
        programs.schedule,
        programs.deadline,
        programs.language,
        pcr.revision,
        pcr.code,
	encode(pcr.checksum, 'hex') AS checksum
FROM program_code_revisions AS pcr, programs
WHERE programs.uuid = pcr.program_uuid
AND programs.state = 'active'
AND programs.type = 'module'
AND pcr.signed IS NOT NULL
ORDER BY
	pcr.program_uuid,
	pcr.revision DESC
`

type FindAllModulesRow struct {
	Name        string
	ProgramUuid uuid.UUID
	Type        string
	Schedule    string
	Deadline    int32
	Language    string
	Revision    int32
	Code        []byte
	Checksum    string
}

func (q *Queries) FindAllModules(ctx context.Context) ([]FindAllModulesRow, error) {
	rows, err := q.query(ctx, q.findAllModulesStmt, findAllModules)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllModulesRow{}
	for rows.Next() {
		var i FindAllModulesRow
		if err := rows.Scan(
			&i.Name,
			&i.ProgramUuid,
			&i.Type,
			&i.Schedule,
			&i.Deadline,
			&i.Language,
			&i.Revision,
			&i.Code,
			&i.Checksum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllRoutineRevisions = `-- name: FindAllRoutineRevisions :many
WITH p AS (
	SELECT
        	pcr.program_uuid, pcr.revision, pcr.created, pcr.signed, pcr.created_by, pcr.signed_by, pcr.code, pcr.checksum,
		programs.uuid, programs.name, programs.type, programs.state, programs.schedule, programs.deadline, programs.language, programs.tags,
		RANK () OVER (
			PARTITION BY pcr.program_uuid
			ORDER BY revision DESC
		) revision_rank
	FROM program_code_revisions AS pcr
	INNER JOIN programs ON programs.uuid = pcr.program_uuid
	WHERE pcr.signed IS NOT NULL
	AND programs.type IN ('routine', 'webhook')
	AND programs.state = 'active'
)
SELECT
	p.name,
	p.program_uuid,
        p.type,
        p.schedule,
        p.deadline,
        p.language,
        p.revision,
        p.code,
        encode(p.checksum, 'hex') AS checksum
FROM p
WHERE revision_rank = 1
`

type FindAllRoutineRevisionsRow struct {
	Name        string
	ProgramUuid uuid.UUID
	Type        string
	Schedule    string
	Deadline    int32
	Language    string
	Revision    int32
	Code        []byte
	Checksum    string
}

func (q *Queries) FindAllRoutineRevisions(ctx context.Context) ([]FindAllRoutineRevisionsRow, error) {
	rows, err := q.query(ctx, q.findAllRoutineRevisionsStmt, findAllRoutineRevisions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindAllRoutineRevisionsRow{}
	for rows.Next() {
		var i FindAllRoutineRevisionsRow
		if err := rows.Scan(
			&i.Name,
			&i.ProgramUuid,
			&i.Type,
			&i.Schedule,
			&i.Deadline,
			&i.Language,
			&i.Revision,
			&i.Code,
			&i.Checksum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProgramByUUID = `-- name: FindProgramByUUID :one
SELECT
	uuid, name, type, state, schedule, deadline, language, tags
FROM programs
WHERE programs.uuid = $1
LIMIT 1
`

func (q *Queries) FindProgramByUUID(ctx context.Context, uuid uuid.UUID) (Program, error) {
	row := q.queryRow(ctx, q.findProgramByUUIDStmt, findProgramByUUID, uuid)
	var i Program
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Type,
		&i.State,
		&i.Schedule,
		&i.Deadline,
		&i.Language,
		pq.Array(&i.Tags),
	)
	return i, err
}

const findProgramCodeRevisions = `-- name: FindProgramCodeRevisions :many
SELECT
	revision, created, created_by, signed, signed_by, encode(checksum, 'hex') AS checksum
FROM
	program_code_revisions
WHERE
	program_uuid = $1
ORDER BY revision ASC
`

type FindProgramCodeRevisionsRow struct {
	Revision  int32
	Created   time.Time
	CreatedBy uuid.UUID
	Signed    sql.NullTime
	SignedBy  uuid.UUID
	Checksum  string
}

func (q *Queries) FindProgramCodeRevisions(ctx context.Context, programUuid uuid.UUID) ([]FindProgramCodeRevisionsRow, error) {
	rows, err := q.query(ctx, q.findProgramCodeRevisionsStmt, findProgramCodeRevisions, programUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindProgramCodeRevisionsRow{}
	for rows.Next() {
		var i FindProgramCodeRevisionsRow
		if err := rows.Scan(
			&i.Revision,
			&i.Created,
			&i.CreatedBy,
			&i.Signed,
			&i.SignedBy,
			&i.Checksum,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPrograms = `-- name: FindPrograms :many
WITH usr AS (
	SELECT users.uuid
	FROM users, user_tokens
	WHERE user_tokens.user_uuid = users.uuid
	AND user_tokens.token_hash = sha256($3)
	LIMIT 1
), policies AS (
	SELECT group_policies.effect, group_policies.priority, group_policies.resource
	FROM group_policies, user_groups
	WHERE user_groups.group_uuid = group_policies.group_uuid
	AND user_groups.user_uuid = (SELECT uuid FROM usr)
	AND action = 'read'
)
SELECT
	uuid, name, type, state, schedule, deadline, language, tags
FROM programs
WHERE 'programs/'||programs.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'allow')
)
EXCEPT
SELECT
	uuid, name, type, state, schedule, deadline, language, tags
FROM programs
WHERE 'programs/'||programs.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'deny')
)
ORDER BY name
LIMIT $2::BIGINT
OFFSET $1::BIGINT
`

type FindProgramsParams struct {
	ArgOffset int64
	ArgLimit  int64
	Token     []byte
}

func (q *Queries) FindPrograms(ctx context.Context, arg FindProgramsParams) ([]Program, error) {
	rows, err := q.query(ctx, q.findProgramsStmt, findPrograms, arg.ArgOffset, arg.ArgLimit, arg.Token)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Program{}
	for rows.Next() {
		var i Program
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Type,
			&i.State,
			&i.Schedule,
			&i.Deadline,
			&i.Language,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findProgramsByTags = `-- name: FindProgramsByTags :many
WITH usr AS (
	SELECT users.uuid
	FROM users, user_tokens
	WHERE user_tokens.user_uuid = users.uuid
	AND user_tokens.token_hash = sha256($3)
	LIMIT 1
), policies AS (
	SELECT group_policies.effect, group_policies.priority, group_policies.resource
	FROM group_policies, user_groups
	WHERE user_groups.group_uuid = group_policies.group_uuid
	AND user_groups.user_uuid = (SELECT uuid FROM usr)
	AND action = 'read'
)
SELECT uuid, name, type, state, schedule, deadline, language, tags
FROM programs
WHERE 'programs/'||programs.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'allow')
)
AND $4 && programs.tags
EXCEPT
SELECT uuid, name, type, state, schedule, deadline, language, tags
FROM programs
WHERE 'programs/'||programs.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'deny')
)
AND $4 && programs.tags
ORDER BY name
LIMIT $2::BIGINT
OFFSET $1::BIGINT
`

type FindProgramsByTagsParams struct {
	ArgOffset int64
	ArgLimit  int64
	Token     []byte
	Tags      interface{}
}

func (q *Queries) FindProgramsByTags(ctx context.Context, arg FindProgramsByTagsParams) ([]Program, error) {
	rows, err := q.query(ctx, q.findProgramsByTagsStmt, findProgramsByTags,
		arg.ArgOffset,
		arg.ArgLimit,
		arg.Token,
		arg.Tags,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Program{}
	for rows.Next() {
		var i Program
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Type,
			&i.State,
			&i.Schedule,
			&i.Deadline,
			&i.Language,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNamedModuleCodeAtHead = `-- name: GetNamedModuleCodeAtHead :one
SELECT
	code
FROM program_code_revisions, programs
WHERE program_uuid = programs.uuid
AND programs.name = $1
AND programs.type = 'module'
AND programs.state = 'active'
AND programs.language = $2
AND program_code_revisions.signed IS NOT NULL
ORDER BY revision DESC
LIMIT 1
`

type GetNamedModuleCodeAtHeadParams struct {
	Name     string
	Language string
}

func (q *Queries) GetNamedModuleCodeAtHead(ctx context.Context, arg GetNamedModuleCodeAtHeadParams) ([]byte, error) {
	row := q.queryRow(ctx, q.getNamedModuleCodeAtHeadStmt, getNamedModuleCodeAtHead, arg.Name, arg.Language)
	var code []byte
	err := row.Scan(&code)
	return code, err
}

const getNamedModuleCodeAtRevision = `-- name: GetNamedModuleCodeAtRevision :one
SELECT
	code
FROM program_code_revisions, programs
WHERE program_uuid = programs.uuid
AND programs.name = $1
AND programs.type = 'module'
AND programs.state = 'active'
AND programs.language = $2
AND program_code_revisions.signed IS NOT NULL
AND program_code_revisions.revision = $3
LIMIT 1
`

type GetNamedModuleCodeAtRevisionParams struct {
	Name     string
	Language string
	Revision int32
}

func (q *Queries) GetNamedModuleCodeAtRevision(ctx context.Context, arg GetNamedModuleCodeAtRevisionParams) ([]byte, error) {
	row := q.queryRow(ctx, q.getNamedModuleCodeAtRevisionStmt, getNamedModuleCodeAtRevision, arg.Name, arg.Language, arg.Revision)
	var code []byte
	err := row.Scan(&code)
	return code, err
}

const getProgramCodeAtHead = `-- name: GetProgramCodeAtHead :one
SELECT
	code, revision
FROM program_code_revisions
WHERE program_uuid = $1
ORDER BY revision DESC
LIMIT 1
`

type GetProgramCodeAtHeadRow struct {
	Code     []byte
	Revision int32
}

func (q *Queries) GetProgramCodeAtHead(ctx context.Context, programUuid uuid.UUID) (GetProgramCodeAtHeadRow, error) {
	row := q.queryRow(ctx, q.getProgramCodeAtHeadStmt, getProgramCodeAtHead, programUuid)
	var i GetProgramCodeAtHeadRow
	err := row.Scan(&i.Code, &i.Revision)
	return i, err
}

const getProgramCodeAtRevision = `-- name: GetProgramCodeAtRevision :one
SELECT
	code
FROM program_code_revisions
WHERE program_uuid = $1
AND revision = $2
LIMIT 1
`

type GetProgramCodeAtRevisionParams struct {
	ProgramUuid uuid.UUID
	Revision    int32
}

func (q *Queries) GetProgramCodeAtRevision(ctx context.Context, arg GetProgramCodeAtRevisionParams) ([]byte, error) {
	row := q.queryRow(ctx, q.getProgramCodeAtRevisionStmt, getProgramCodeAtRevision, arg.ProgramUuid, arg.Revision)
	var code []byte
	err := row.Scan(&code)
	return code, err
}

const getSignedProgramCodeAtHead = `-- name: GetSignedProgramCodeAtHead :one
SELECT
	code, revision
FROM program_code_revisions
WHERE program_uuid = $1
AND signed IS NOT NULL
ORDER BY revision DESC
LIMIT 1
`

type GetSignedProgramCodeAtHeadRow struct {
	Code     []byte
	Revision int32
}

func (q *Queries) GetSignedProgramCodeAtHead(ctx context.Context, programUuid uuid.UUID) (GetSignedProgramCodeAtHeadRow, error) {
	row := q.queryRow(ctx, q.getSignedProgramCodeAtHeadStmt, getSignedProgramCodeAtHead, programUuid)
	var i GetSignedProgramCodeAtHeadRow
	err := row.Scan(&i.Code, &i.Revision)
	return i, err
}

const setProgramDeadlineByUUID = `-- name: SetProgramDeadlineByUUID :execrows
UPDATE programs
SET deadline = $1
WHERE programs.uuid = $2
`

type SetProgramDeadlineByUUIDParams struct {
	Deadline int32
	Uuid     uuid.UUID
}

func (q *Queries) SetProgramDeadlineByUUID(ctx context.Context, arg SetProgramDeadlineByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramDeadlineByUUIDStmt, setProgramDeadlineByUUID, arg.Deadline, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramLanguageByUUID = `-- name: SetProgramLanguageByUUID :execrows
UPDATE programs
SET language = $1
WHERE programs.uuid = $2
`

type SetProgramLanguageByUUIDParams struct {
	Language string
	Uuid     uuid.UUID
}

func (q *Queries) SetProgramLanguageByUUID(ctx context.Context, arg SetProgramLanguageByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramLanguageByUUIDStmt, setProgramLanguageByUUID, arg.Language, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramNameByUUID = `-- name: SetProgramNameByUUID :execrows
UPDATE programs
SET name = $1
WHERE programs.uuid = $2
`

type SetProgramNameByUUIDParams struct {
	Name string
	Uuid uuid.UUID
}

func (q *Queries) SetProgramNameByUUID(ctx context.Context, arg SetProgramNameByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramNameByUUIDStmt, setProgramNameByUUID, arg.Name, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramScheduleByUUID = `-- name: SetProgramScheduleByUUID :execrows
UPDATE programs
SET schedule = $1
WHERE programs.uuid = $2
`

type SetProgramScheduleByUUIDParams struct {
	Schedule string
	Uuid     uuid.UUID
}

func (q *Queries) SetProgramScheduleByUUID(ctx context.Context, arg SetProgramScheduleByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramScheduleByUUIDStmt, setProgramScheduleByUUID, arg.Schedule, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramStateByUUID = `-- name: SetProgramStateByUUID :execrows
UPDATE programs
SET state = $1
WHERE programs.uuid = $2
`

type SetProgramStateByUUIDParams struct {
	State string
	Uuid  uuid.UUID
}

func (q *Queries) SetProgramStateByUUID(ctx context.Context, arg SetProgramStateByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramStateByUUIDStmt, setProgramStateByUUID, arg.State, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramTags = `-- name: SetProgramTags :execrows
UPDATE programs
SET tags = $1
WHERE programs.uuid = $2
`

type SetProgramTagsParams struct {
	Tags []string
	Uuid uuid.UUID
}

func (q *Queries) SetProgramTags(ctx context.Context, arg SetProgramTagsParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramTagsStmt, setProgramTags, pq.Array(arg.Tags), arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setProgramTypeByUUID = `-- name: SetProgramTypeByUUID :execrows
UPDATE programs
SET type = $1
WHERE programs.uuid = $2
`

type SetProgramTypeByUUIDParams struct {
	Type string
	Uuid uuid.UUID
}

func (q *Queries) SetProgramTypeByUUID(ctx context.Context, arg SetProgramTypeByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setProgramTypeByUUIDStmt, setProgramTypeByUUID, arg.Type, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const signProgramCodeRevision = `-- name: SignProgramCodeRevision :execrows
UPDATE program_code_revisions
SET signed_by = $1, signed = now()
WHERE program_uuid = $2
AND revision = $3
`

type SignProgramCodeRevisionParams struct {
	SignedBy    uuid.UUID
	ProgramUuid uuid.UUID
	Revision    int32
}

func (q *Queries) SignProgramCodeRevision(ctx context.Context, arg SignProgramCodeRevisionParams) (int64, error) {
	result, err := q.exec(ctx, q.signProgramCodeRevisionStmt, signProgramCodeRevision, arg.SignedBy, arg.ProgramUuid, arg.Revision)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
