// Code generated by sqlc. DO NOT EDIT.
// source: datasets.sql

package postgresql

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createDataset = `-- name: CreateDataset :one
WITH ds AS (
	INSERT INTO datasets (name, format, content, size, belongs_to, created_by, updated_by, tags)
	VALUES(
		$1::text,
		$2::text,
		$3::bytea,
		length($3)::integer,
		NULLIF($4::uuid, '00000000-0000-0000-0000-000000000000'::uuid),
		$5::uuid,
		$5::uuid,
		$6
	)
	RETURNING
		uuid,
		name,
		format,
		size,
		belongs_to,
		created,
		updated,
		created_by,
		updated_by,
		tags
), grp AS (
	SELECT groups.uuid
	FROM groups, user_groups
	WHERE user_groups.group_uuid = groups.uuid
	AND user_groups.user_uuid = (SELECT created_by FROM ds)
	AND groups.uuid = (
		SELECT users.uuid
		FROM users
		WHERE users.name = groups.name
	)
	LIMIT 1
), grp_policies AS (
	INSERT INTO group_policies(group_uuid, priority, effect, action, resource)
	VALUES (
		(SELECT uuid FROM grp), 0, 'allow', 'create','datasets/'||(SELECT uuid FROM ds)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'read','datasets/'||(SELECT uuid FROM ds)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'update','datasets/'||(SELECT uuid FROM ds)||'/%'
	), (
		(SELECT uuid FROM grp), 0, 'allow', 'delete','datasets/'||(SELECT uuid FROM ds)||'/%'
	)
)
SELECT uuid, name, format, size, belongs_to, created, updated, created_by, updated_by, tags
FROM ds LIMIT 1
`

type CreateDatasetParams struct {
	Name      string
	Format    string
	Content   []byte
	BelongsTo uuid.UUID
	CreatedBy uuid.UUID
	Tags      []string
}

type CreateDatasetRow struct {
	Uuid      uuid.UUID
	Name      string
	Format    string
	Size      int32
	BelongsTo uuid.UUID
	Created   time.Time
	Updated   time.Time
	CreatedBy uuid.UUID
	UpdatedBy uuid.UUID
	Tags      []string
}

func (q *Queries) CreateDataset(ctx context.Context, arg CreateDatasetParams) (CreateDatasetRow, error) {
	row := q.queryRow(ctx, q.createDatasetStmt, createDataset,
		arg.Name,
		arg.Format,
		arg.Content,
		arg.BelongsTo,
		arg.CreatedBy,
		pq.Array(arg.Tags),
	)
	var i CreateDatasetRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Format,
		&i.Size,
		&i.BelongsTo,
		&i.Created,
		&i.Updated,
		&i.CreatedBy,
		&i.UpdatedBy,
		pq.Array(&i.Tags),
	)
	return i, err
}

const deleteDataset = `-- name: DeleteDataset :execrows
DELETE FROM datasets
WHERE datasets.uuid = $1
`

func (q *Queries) DeleteDataset(ctx context.Context, uuid uuid.UUID) (int64, error) {
	result, err := q.exec(ctx, q.deleteDatasetStmt, deleteDataset, uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const existsDataset = `-- name: ExistsDataset :one
SELECT COUNT(*) AS count
FROM datasets
WHERE datasets.uuid = $1
`

func (q *Queries) ExistsDataset(ctx context.Context, uuid uuid.UUID) (int64, error) {
	row := q.queryRow(ctx, q.existsDatasetStmt, existsDataset, uuid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const findDatasetByThing = `-- name: FindDatasetByThing :many
SELECT
	uuid,
	name,
	format,
	size,
	belongs_to,
	created,
	updated,
	created_by,
	updated_by,
	tags
FROM datasets
WHERE datasets.belongs_to = $1
ORDER BY name
`

type FindDatasetByThingRow struct {
	Uuid      uuid.UUID
	Name      string
	Format    string
	Size      int32
	BelongsTo uuid.UUID
	Created   time.Time
	Updated   time.Time
	CreatedBy uuid.UUID
	UpdatedBy uuid.UUID
	Tags      []string
}

func (q *Queries) FindDatasetByThing(ctx context.Context, thingUuid uuid.UUID) ([]FindDatasetByThingRow, error) {
	rows, err := q.query(ctx, q.findDatasetByThingStmt, findDatasetByThing, thingUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindDatasetByThingRow{}
	for rows.Next() {
		var i FindDatasetByThingRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Format,
			&i.Size,
			&i.BelongsTo,
			&i.Created,
			&i.Updated,
			&i.CreatedBy,
			&i.UpdatedBy,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDatasetByUUID = `-- name: FindDatasetByUUID :one
SELECT
	uuid,
	name,
	format,
	size,
	belongs_to,
	created,
	updated,
	created_by,
	updated_by,
	tags
FROM datasets
WHERE datasets.uuid = $1
LIMIT 1
`

type FindDatasetByUUIDRow struct {
	Uuid      uuid.UUID
	Name      string
	Format    string
	Size      int32
	BelongsTo uuid.UUID
	Created   time.Time
	Updated   time.Time
	CreatedBy uuid.UUID
	UpdatedBy uuid.UUID
	Tags      []string
}

func (q *Queries) FindDatasetByUUID(ctx context.Context, uuid uuid.UUID) (FindDatasetByUUIDRow, error) {
	row := q.queryRow(ctx, q.findDatasetByUUIDStmt, findDatasetByUUID, uuid)
	var i FindDatasetByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Format,
		&i.Size,
		&i.BelongsTo,
		&i.Created,
		&i.Updated,
		&i.CreatedBy,
		&i.UpdatedBy,
		pq.Array(&i.Tags),
	)
	return i, err
}

const findDatasets = `-- name: FindDatasets :many
WITH usr AS (
	SELECT users.uuid
	FROM users, user_tokens
	WHERE user_tokens.user_uuid = users.uuid
	AND user_tokens.token_hash = sha256($3)
	LIMIT 1
), policies AS (
	SELECT group_policies.effect, group_policies.priority, group_policies.resource
	FROM group_policies, user_groups
	WHERE user_groups.group_uuid = group_policies.group_uuid
	AND user_groups.user_uuid = (SELECT uuid FROM usr)
	AND action = 'read'
)
SELECT
	uuid,
	name,
	format,
	size,
	belongs_to,
	created,
	updated,
	created_by,
	updated_by,
	tags
FROM datasets
WHERE 'datasets/'||datasets.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'allow')
)
EXCEPT
SELECT
	uuid,
	name,
	format,
	size,
	belongs_to,
	created,
	updated,
	created_by,
	updated_by,
	tags
FROM datasets
WHERE 'datasets/'||datasets.uuid LIKE ANY(
	(SELECT resource FROM policies WHERE effect = 'deny')
)
ORDER BY name
LIMIT $2::BIGINT
OFFSET $1::BIGINT
`

type FindDatasetsParams struct {
	ArgOffset int64
	ArgLimit  int64
	Token     []byte
}

type FindDatasetsRow struct {
	Uuid      uuid.UUID
	Name      string
	Format    string
	Size      int32
	BelongsTo uuid.UUID
	Created   time.Time
	Updated   time.Time
	CreatedBy uuid.UUID
	UpdatedBy uuid.UUID
	Tags      []string
}

func (q *Queries) FindDatasets(ctx context.Context, arg FindDatasetsParams) ([]FindDatasetsRow, error) {
	rows, err := q.query(ctx, q.findDatasetsStmt, findDatasets, arg.ArgOffset, arg.ArgLimit, arg.Token)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindDatasetsRow{}
	for rows.Next() {
		var i FindDatasetsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Format,
			&i.Size,
			&i.BelongsTo,
			&i.Created,
			&i.Updated,
			&i.CreatedBy,
			&i.UpdatedBy,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetContentByUUID = `-- name: GetDatasetContentByUUID :one
SELECT format, content
FROM datasets
WHERE datasets.uuid = $1
LIMIT 1
`

type GetDatasetContentByUUIDRow struct {
	Format  string
	Content []byte
}

func (q *Queries) GetDatasetContentByUUID(ctx context.Context, uuid uuid.UUID) (GetDatasetContentByUUIDRow, error) {
	row := q.queryRow(ctx, q.getDatasetContentByUUIDStmt, getDatasetContentByUUID, uuid)
	var i GetDatasetContentByUUIDRow
	err := row.Scan(&i.Format, &i.Content)
	return i, err
}

const setDatasetContentByUUID = `-- name: SetDatasetContentByUUID :execrows
UPDATE datasets
SET content = $1
WHERE datasets.uuid = $2
`

type SetDatasetContentByUUIDParams struct {
	Content []byte
	Uuid    uuid.UUID
}

func (q *Queries) SetDatasetContentByUUID(ctx context.Context, arg SetDatasetContentByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setDatasetContentByUUIDStmt, setDatasetContentByUUID, arg.Content, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setDatasetFormatByUUID = `-- name: SetDatasetFormatByUUID :execrows
UPDATE datasets
SET format = $1
WHERE datasets.uuid = $2
`

type SetDatasetFormatByUUIDParams struct {
	Format string
	Uuid   uuid.UUID
}

func (q *Queries) SetDatasetFormatByUUID(ctx context.Context, arg SetDatasetFormatByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setDatasetFormatByUUIDStmt, setDatasetFormatByUUID, arg.Format, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setDatasetNameByUUID = `-- name: SetDatasetNameByUUID :execrows
UPDATE datasets
SET name = $1
WHERE datasets.uuid = $2
`

type SetDatasetNameByUUIDParams struct {
	Name string
	Uuid uuid.UUID
}

func (q *Queries) SetDatasetNameByUUID(ctx context.Context, arg SetDatasetNameByUUIDParams) (int64, error) {
	result, err := q.exec(ctx, q.setDatasetNameByUUIDStmt, setDatasetNameByUUID, arg.Name, arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setDatasetTags = `-- name: SetDatasetTags :execrows
UPDATE datasets
SET tags = $1
WHERE datasets.uuid = $2
`

type SetDatasetTagsParams struct {
	Tags []string
	Uuid uuid.UUID
}

func (q *Queries) SetDatasetTags(ctx context.Context, arg SetDatasetTagsParams) (int64, error) {
	result, err := q.exec(ctx, q.setDatasetTagsStmt, setDatasetTags, pq.Array(arg.Tags), arg.Uuid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
