// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get alerts. TBD
	// (GET /v2/alerts)
	FindAlerts(w http.ResponseWriter, r *http.Request, params FindAlertsParams)
	// Get datasets.
	// (GET /v2/datasets)
	FindDatasets(w http.ResponseWriter, r *http.Request, params FindDatasetsParams)
	// Add dataset.
	// (POST /v2/datasets)
	AddDatasets(w http.ResponseWriter, r *http.Request)
	// Delete a specific dataset.
	// (DELETE /v2/datasets/{uuid})
	DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get a specific dataset.
	// (GET /v2/datasets/{uuid})
	FindDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a specific dataset.
	// (PUT /v2/datasets/{uuid})
	UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Assemble the uploaded parts. TBD.
	// (POST /v2/datasets/{uuid}/assemble)
	AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AssembleDatasetPartsByKeyParams)
	// List parts. TBD.
	// (GET /v2/datasets/{uuid}/parts)
	ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params ListDatasetPartsByKeyParams)
	// Upload each part of the data-set content. TBD.
	// (PUT /v2/datasets/{uuid}/parts)
	UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params UploadDatasetContentByKeyParams)
	// Download dataset content
	// (GET /v2/datasets/{uuid}/raw)
	GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetRawDatasetByUuidParams)
	// Cancel content upload. TBD.
	// (DELETE /v2/datasets/{uuid}/uploads)
	DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDatasetUploadByKeyParams)
	// Initialize a content upload. TBD.
	// (POST /v2/datasets/{uuid}/uploads)
	InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get groups.
	// (GET /v2/groups)
	FindGroups(w http.ResponseWriter, r *http.Request, params FindGroupsParams)
	// Add a new group.
	// (POST /v2/groups)
	AddGroup(w http.ResponseWriter, r *http.Request)
	// Delete a Group
	// (DELETE /v2/groups/{uuid})
	DeleteGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get info about a Group
	// (GET /v2/groups/{uuid})
	FindGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a Group
	// (PUT /v2/groups/{uuid})
	UpdateGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies for a Group
	// (GET /v2/groups/{uuid}/policies)
	FindPoliciesForGroup(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies
	// (GET /v2/policies)
	FindPolicies(w http.ResponseWriter, r *http.Request, params FindPoliciesParams)
	// Add a new Policy
	// (POST /v2/policies)
	AddPolicy(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/policies/{uuid})
	DeletePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/policies/{uuid})
	FindPolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/policies/{uuid})
	UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs)
	FindPrograms(w http.ResponseWriter, r *http.Request, params FindProgramsParams)

	// (POST /v2/programs)
	AddProgram(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/programs/{uuid})
	DeleteProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid})
	FindProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/programs/{uuid})
	UpdateProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/code)
	GetCodeFromProgram(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (POST /v2/programs/{uuid}/code)
	AddProgramCodeRevision(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/diff)
	GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetProgramCodeRevisionsDiffParams)

	// (GET /v2/programs/{uuid}/revisions)
	GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (DELETE /v2/programs/{uuid}/revisions/{revision_id})
	DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)

	// (PUT /v2/programs/{uuid}/revisions/{revision_id}/sign)
	SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)
	// TBD
	// (POST /v2/programs/{uuid}/webhook)
	ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things)
	FindThings(w http.ResponseWriter, r *http.Request, params FindThingsParams)

	// (POST /v2/things)
	AddThing(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/things/{uuid})
	DeleteThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things/{uuid})
	FindThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Thing.
	// (PUT /v2/things/{uuid})
	UpdateThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Datasets assigned to a Thing.
	// (GET /v2/things/{uuid}/datasets)
	FindDatasetsForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Timeseries assigned to a Thing.
	// (GET /v2/things/{uuid}/timeseries)
	FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries)
	FindTimeSeries(w http.ResponseWriter, r *http.Request, params FindTimeSeriesParams)

	// (POST /v2/timeseries)
	AddTimeSeries(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/timeseries/{uuid})
	DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries/{uuid})
	FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Timeseries.
	// (PUT /v2/timeseries/{uuid})
	UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete a range of Timeseries data.
	// (DELETE /v2/timeseries/{uuid}/data)
	DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDataFromTimeSeriesParams)
	// Get a range of Timeseries data.
	// (GET /v2/timeseries/{uuid}/data)
	QueryTimeseriesForData(w http.ResponseWriter, r *http.Request, uuid UuidParam, params QueryTimeseriesForDataParams)
	// Add data to Timeseries
	// (POST /v2/timeseries/{uuid}/data)
	AddDataToTimeseries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AddDataToTimeseriesParams)
	// Query for data from Time series.
	// (GET /v2/tsquery)
	FindTsdataByQuery(w http.ResponseWriter, r *http.Request, params FindTsdataByQueryParams)
	// Returns a list of user objects.
	// (GET /v2/users)
	FindUsers(w http.ResponseWriter, r *http.Request, params FindUsersParams)

	// (POST /v2/users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Who am I
	// (GET /v2/users/me)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Delete a User
	// (DELETE /v2/users/{uuid})
	DeleteUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid})
	FindUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a User
	// (PUT /v2/users/{uuid})
	UpdateUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid}/policies)
	FindPoliciesForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// TBD
	// (PUT /v2/users/{uuid}/rate)
	SetRequestRateForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Access tokens
	// (GET /v2/users/{uuid}/tokens)
	FindTokensForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Generate a new access token.
	// (POST /v2/users/{uuid}/tokens)
	AddNewTokenToUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete access token.
	// (DELETE /v2/users/{uuid}/tokens/{token_uuid})
	DeleteTokenForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam, tokenUuid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// FindAlerts operation middleware
func (siw *ServerInterfaceWrapper) FindAlerts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:alerts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAlertsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAlerts(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasets operation middleware
func (siw *ServerInterfaceWrapper) FindDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindDatasetsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasets(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDatasets operation middleware
func (siw *ServerInterfaceWrapper) AddDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDatasets(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AssembleDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssembleDatasetPartsByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssembleDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDatasetPartsByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadDatasetContentByKey operation middleware
func (siw *ServerInterfaceWrapper) UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadDatasetContentByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDatasetContentByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRawDatasetByUuidParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchParam
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawDatasetByUuid(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetUploadByKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDatasetUploadByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetUploadByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InitializeDatasetUploadByUuid operation middleware
func (siw *ServerInterfaceWrapper) InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitializeDatasetUploadByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroups operation middleware
func (siw *ServerInterfaceWrapper) FindGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroup operation middleware
func (siw *ServerInterfaceWrapper) AddGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:groups"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForGroup operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForGroup(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicies operation middleware
func (siw *ServerInterfaceWrapper) FindPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPoliciesParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_uuids" -------------
	if paramValue := r.URL.Query().Get("group_uuids"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "group_uuids", r.URL.Query(), &params.GroupUuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter group_uuids: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddPolicy operation middleware
func (siw *ServerInterfaceWrapper) AddPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPolicy(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindPolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPrograms operation middleware
func (siw *ServerInterfaceWrapper) FindPrograms(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindProgramsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPrograms(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgram operation middleware
func (siw *ServerInterfaceWrapper) AddProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgram(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCodeFromProgram operation middleware
func (siw *ServerInterfaceWrapper) GetCodeFromProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCodeFromProgram(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgramCodeRevision operation middleware
func (siw *ServerInterfaceWrapper) AddProgramCodeRevision(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgramCodeRevision(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisionsDiff operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions/diff"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramCodeRevisionsDiffParams

	// ------------- Required query parameter "rev_a" -------------
	if paramValue := r.URL.Query().Get("rev_a"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_a is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_a", r.URL.Query(), &params.RevA)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_a: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "rev_b" -------------
	if paramValue := r.URL.Query().Get("rev_b"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_b is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_b", r.URL.Query(), &params.RevB)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_b: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisionsDiff(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisions(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExecuteProgramWebhook operation middleware
func (siw *ServerInterfaceWrapper) ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/webhook"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteProgramWebhook(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThings operation middleware
func (siw *ServerInterfaceWrapper) FindThings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindThingsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThings(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddThing operation middleware
func (siw *ServerInterfaceWrapper) AddThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:things"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddThing(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetsForThing operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetsForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}/datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetsForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesForThing operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTimeSeriesParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeries(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) AddTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimeSeries(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTimeseriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimeseriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDataFromTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDataFromTimeSeriesParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDataFromTimeSeries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// QueryTimeseriesForData operation middleware
func (siw *ServerInterfaceWrapper) QueryTimeseriesForData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTimeseriesForDataParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTimeseriesForData(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDataToTimeseries operation middleware
func (siw *ServerInterfaceWrapper) AddDataToTimeseries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddDataToTimeseriesParams

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDataToTimeseries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTsdataByQuery operation middleware
func (siw *ServerInterfaceWrapper) FindTsdataByQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:tsquery"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTsdataByQueryParams

	// ------------- Required query parameter "uuids" -------------
	if paramValue := r.URL.Query().Get("uuids"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uuids is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuids", r.URL.Query(), &params.Uuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuids: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTsdataByQuery(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUsers operation middleware
func (siw *ServerInterfaceWrapper) FindUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUsersParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/me"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForUser operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRequestRateForUser operation middleware
func (siw *ServerInterfaceWrapper) SetRequestRateForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}/rate"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRequestRateForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTokensForUser operation middleware
func (siw *ServerInterfaceWrapper) FindTokensForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTokensForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddNewTokenToUser operation middleware
func (siw *ServerInterfaceWrapper) AddNewTokenToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddNewTokenToUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTokenForUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteTokenForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "token_uuid" -------------
	var tokenUuid string

	err = runtime.BindStyledParameter("simple", false, "token_uuid", chi.URLParam(r, "token_uuid"), &tokenUuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter token_uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}/tokens/{token_uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTokenForUser(w, r, uuid, tokenUuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/alerts", wrapper.FindAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets", wrapper.FindDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets", wrapper.AddDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}", wrapper.DeleteDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}", wrapper.FindDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}", wrapper.UpdateDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/assemble", wrapper.AssembleDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.ListDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.UploadDatasetContentByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/raw", wrapper.GetRawDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.DeleteDatasetUploadByKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.InitializeDatasetUploadByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups", wrapper.FindGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/groups", wrapper.AddGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/groups/{uuid}", wrapper.DeleteGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}", wrapper.FindGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/groups/{uuid}", wrapper.UpdateGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}/policies", wrapper.FindPoliciesForGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies", wrapper.FindPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/policies", wrapper.AddPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/policies/{uuid}", wrapper.DeletePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies/{uuid}", wrapper.FindPolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/policies/{uuid}", wrapper.UpdatePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs", wrapper.FindPrograms)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs", wrapper.AddProgram)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}", wrapper.DeleteProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}", wrapper.FindProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}", wrapper.UpdateProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.GetCodeFromProgram)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.AddProgramCodeRevision)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/diff", wrapper.GetProgramCodeRevisionsDiff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/revisions", wrapper.GetProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}", wrapper.DeleteProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}/sign", wrapper.SignProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/webhook", wrapper.ExecuteProgramWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things", wrapper.FindThings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/things", wrapper.AddThing)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/things/{uuid}", wrapper.DeleteThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}", wrapper.FindThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/things/{uuid}", wrapper.UpdateThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/datasets", wrapper.FindDatasetsForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/timeseries", wrapper.FindTimeSeriesForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries", wrapper.FindTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries", wrapper.AddTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.DeleteTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.FindTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.UpdateTimeseriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.DeleteDataFromTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.QueryTimeseriesForData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.AddDataToTimeseries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/tsquery", wrapper.FindTsdataByQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users", wrapper.FindUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/me", wrapper.Whoami)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}", wrapper.DeleteUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}", wrapper.FindUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}", wrapper.UpdateUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/policies", wrapper.FindPoliciesForUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}/rate", wrapper.SetRequestRateForUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.FindTokensForUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.AddNewTokenToUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}/tokens/{token_uuid}", wrapper.DeleteTokenForUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
