// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get alerts. TBD
	// (GET /v2/alerts)
	FindAlerts(w http.ResponseWriter, r *http.Request, params FindAlertsParams)
	// Get datasets.
	// (GET /v2/datasets)
	FindDatasets(w http.ResponseWriter, r *http.Request, params FindDatasetsParams)
	// Add dataset.
	// (POST /v2/datasets)
	AddDatasets(w http.ResponseWriter, r *http.Request)
	// Delete a specific dataset.
	// (DELETE /v2/datasets/{uuid})
	DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get a specific dataset.
	// (GET /v2/datasets/{uuid})
	FindDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a specific dataset.
	// (PUT /v2/datasets/{uuid})
	UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Assemble the uploaded parts. TBD.
	// (POST /v2/datasets/{uuid}/assemble)
	AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AssembleDatasetPartsByKeyParams)
	// List parts. TBD.
	// (GET /v2/datasets/{uuid}/parts)
	ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params ListDatasetPartsByKeyParams)
	// Upload each part of the data-set content. TBD.
	// (PUT /v2/datasets/{uuid}/parts)
	UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params UploadDatasetContentByKeyParams)
	// Download dataset content
	// (GET /v2/datasets/{uuid}/raw)
	GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetRawDatasetByUuidParams)
	// Cancel content upload. TBD.
	// (DELETE /v2/datasets/{uuid}/uploads)
	DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDatasetUploadByKeyParams)
	// Initialize a content upload. TBD.
	// (POST /v2/datasets/{uuid}/uploads)
	InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get groups.
	// (GET /v2/groups)
	FindGroups(w http.ResponseWriter, r *http.Request, params FindGroupsParams)
	// Add a new group.
	// (POST /v2/groups)
	AddGroup(w http.ResponseWriter, r *http.Request)
	// Delete a Group
	// (DELETE /v2/groups/{uuid})
	DeleteGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get info about a Group
	// (GET /v2/groups/{uuid})
	FindGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a Group
	// (PUT /v2/groups/{uuid})
	UpdateGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies for a Group
	// (GET /v2/groups/{uuid}/policies)
	FindPoliciesForGroup(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies
	// (GET /v2/policies)
	FindPolicies(w http.ResponseWriter, r *http.Request, params FindPoliciesParams)
	// Add a new Policy
	// (POST /v2/policies)
	AddPolicy(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/policies/{uuid})
	DeletePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/policies/{uuid})
	FindPolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/policies/{uuid})
	UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs)
	FindPrograms(w http.ResponseWriter, r *http.Request, params FindProgramsParams)

	// (POST /v2/programs)
	AddProgram(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/programs/{uuid})
	DeleteProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid})
	FindProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/programs/{uuid})
	UpdateProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/code)
	GetCodeFromProgram(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (POST /v2/programs/{uuid}/code)
	AddProgramCodeRevision(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/diff)
	GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetProgramCodeRevisionsDiffParams)

	// (GET /v2/programs/{uuid}/revisions)
	GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (DELETE /v2/programs/{uuid}/revisions/{revision_id})
	DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)

	// (PUT /v2/programs/{uuid}/revisions/{revision_id}/sign)
	SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)
	// TBD
	// (POST /v2/programs/{uuid}/webhook)
	ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things)
	FindThings(w http.ResponseWriter, r *http.Request, params FindThingsParams)

	// (POST /v2/things)
	AddThing(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/things/{uuid})
	DeleteThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things/{uuid})
	FindThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Thing.
	// (PUT /v2/things/{uuid})
	UpdateThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Datasets assigned to a Thing.
	// (GET /v2/things/{uuid}/datasets)
	FindDatasetsForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Timeseries assigned to a Thing.
	// (GET /v2/things/{uuid}/timeseries)
	FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries)
	FindTimeSeries(w http.ResponseWriter, r *http.Request, params FindTimeSeriesParams)

	// (POST /v2/timeseries)
	AddTimeSeries(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/timeseries/{uuid})
	DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries/{uuid})
	FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Timeseries.
	// (PUT /v2/timeseries/{uuid})
	UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete a range of Timeseries data.
	// (DELETE /v2/timeseries/{uuid}/data)
	DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDataFromTimeSeriesParams)
	// Get a range of Timeseries data.
	// (GET /v2/timeseries/{uuid}/data)
	QueryTimeseriesForData(w http.ResponseWriter, r *http.Request, uuid UuidParam, params QueryTimeseriesForDataParams)
	// Add data to Timeseries
	// (POST /v2/timeseries/{uuid}/data)
	AddDataToTimeseries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AddDataToTimeseriesParams)
	// Query for data from Time series.
	// (GET /v2/tsquery)
	FindTsdataByQuery(w http.ResponseWriter, r *http.Request, params FindTsdataByQueryParams)
	// Returns a list of user objects.
	// (GET /v2/users)
	FindUsers(w http.ResponseWriter, r *http.Request, params FindUsersParams)

	// (POST /v2/users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Who am I
	// (GET /v2/users/me)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Delete a User
	// (DELETE /v2/users/{uuid})
	DeleteUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid})
	FindUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a User
	// (PUT /v2/users/{uuid})
	UpdateUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid}/policies)
	FindPoliciesForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// TBD
	// (PUT /v2/users/{uuid}/rate)
	SetRequestRateForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Access tokens
	// (GET /v2/users/{uuid}/tokens)
	FindTokensForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Generate a new access token.
	// (POST /v2/users/{uuid}/tokens)
	AddNewTokenToUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete access token.
	// (DELETE /v2/users/{uuid}/tokens/{token_uuid})
	DeleteTokenForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam, tokenUuid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// FindAlerts operation middleware
func (siw *ServerInterfaceWrapper) FindAlerts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:alerts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAlertsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAlerts(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasets operation middleware
func (siw *ServerInterfaceWrapper) FindDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindDatasetsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasets(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDatasets operation middleware
func (siw *ServerInterfaceWrapper) AddDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDatasets(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AssembleDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssembleDatasetPartsByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssembleDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDatasetPartsByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadDatasetContentByKey operation middleware
func (siw *ServerInterfaceWrapper) UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadDatasetContentByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDatasetContentByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRawDatasetByUuidParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchParam
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawDatasetByUuid(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetUploadByKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDatasetUploadByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetUploadByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InitializeDatasetUploadByUuid operation middleware
func (siw *ServerInterfaceWrapper) InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitializeDatasetUploadByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroups operation middleware
func (siw *ServerInterfaceWrapper) FindGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroup operation middleware
func (siw *ServerInterfaceWrapper) AddGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:groups"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForGroup operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForGroup(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicies operation middleware
func (siw *ServerInterfaceWrapper) FindPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPoliciesParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_uuids" -------------
	if paramValue := r.URL.Query().Get("group_uuids"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "group_uuids", r.URL.Query(), &params.GroupUuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter group_uuids: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddPolicy operation middleware
func (siw *ServerInterfaceWrapper) AddPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPolicy(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindPolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPrograms operation middleware
func (siw *ServerInterfaceWrapper) FindPrograms(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindProgramsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPrograms(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgram operation middleware
func (siw *ServerInterfaceWrapper) AddProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgram(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCodeFromProgram operation middleware
func (siw *ServerInterfaceWrapper) GetCodeFromProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCodeFromProgram(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgramCodeRevision operation middleware
func (siw *ServerInterfaceWrapper) AddProgramCodeRevision(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgramCodeRevision(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisionsDiff operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions/diff"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramCodeRevisionsDiffParams

	// ------------- Required query parameter "rev_a" -------------
	if paramValue := r.URL.Query().Get("rev_a"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_a is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_a", r.URL.Query(), &params.RevA)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_a: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "rev_b" -------------
	if paramValue := r.URL.Query().Get("rev_b"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_b is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_b", r.URL.Query(), &params.RevB)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_b: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisionsDiff(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisions(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExecuteProgramWebhook operation middleware
func (siw *ServerInterfaceWrapper) ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/webhook"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteProgramWebhook(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThings operation middleware
func (siw *ServerInterfaceWrapper) FindThings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindThingsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThings(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddThing operation middleware
func (siw *ServerInterfaceWrapper) AddThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:things"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddThing(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetsForThing operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetsForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}/datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetsForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesForThing operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTimeSeriesParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeries(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) AddTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimeSeries(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTimeseriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimeseriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDataFromTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDataFromTimeSeriesParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDataFromTimeSeries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// QueryTimeseriesForData operation middleware
func (siw *ServerInterfaceWrapper) QueryTimeseriesForData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTimeseriesForDataParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTimeseriesForData(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDataToTimeseries operation middleware
func (siw *ServerInterfaceWrapper) AddDataToTimeseries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddDataToTimeseriesParams

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDataToTimeseries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTsdataByQuery operation middleware
func (siw *ServerInterfaceWrapper) FindTsdataByQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:tsquery"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTsdataByQueryParams

	// ------------- Required query parameter "uuids" -------------
	if paramValue := r.URL.Query().Get("uuids"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uuids is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuids", r.URL.Query(), &params.Uuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuids: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTsdataByQuery(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUsers operation middleware
func (siw *ServerInterfaceWrapper) FindUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUsersParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/me"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForUser operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRequestRateForUser operation middleware
func (siw *ServerInterfaceWrapper) SetRequestRateForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}/rate"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRequestRateForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTokensForUser operation middleware
func (siw *ServerInterfaceWrapper) FindTokensForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTokensForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddNewTokenToUser operation middleware
func (siw *ServerInterfaceWrapper) AddNewTokenToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddNewTokenToUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTokenForUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteTokenForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "token_uuid" -------------
	var tokenUuid string

	err = runtime.BindStyledParameter("simple", false, "token_uuid", chi.URLParam(r, "token_uuid"), &tokenUuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter token_uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}/tokens/{token_uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTokenForUser(w, r, uuid, tokenUuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/alerts", wrapper.FindAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets", wrapper.FindDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets", wrapper.AddDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}", wrapper.DeleteDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}", wrapper.FindDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}", wrapper.UpdateDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/assemble", wrapper.AssembleDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.ListDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.UploadDatasetContentByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/raw", wrapper.GetRawDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.DeleteDatasetUploadByKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.InitializeDatasetUploadByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups", wrapper.FindGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/groups", wrapper.AddGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/groups/{uuid}", wrapper.DeleteGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}", wrapper.FindGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/groups/{uuid}", wrapper.UpdateGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}/policies", wrapper.FindPoliciesForGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies", wrapper.FindPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/policies", wrapper.AddPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/policies/{uuid}", wrapper.DeletePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies/{uuid}", wrapper.FindPolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/policies/{uuid}", wrapper.UpdatePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs", wrapper.FindPrograms)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs", wrapper.AddProgram)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}", wrapper.DeleteProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}", wrapper.FindProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}", wrapper.UpdateProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.GetCodeFromProgram)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.AddProgramCodeRevision)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/diff", wrapper.GetProgramCodeRevisionsDiff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/revisions", wrapper.GetProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}", wrapper.DeleteProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}/sign", wrapper.SignProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/webhook", wrapper.ExecuteProgramWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things", wrapper.FindThings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/things", wrapper.AddThing)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/things/{uuid}", wrapper.DeleteThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}", wrapper.FindThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/things/{uuid}", wrapper.UpdateThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/datasets", wrapper.FindDatasetsForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/timeseries", wrapper.FindTimeSeriesForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries", wrapper.FindTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries", wrapper.AddTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.DeleteTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.FindTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.UpdateTimeseriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.DeleteDataFromTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.QueryTimeseriesForData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.AddDataToTimeseries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/tsquery", wrapper.FindTsdataByQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users", wrapper.FindUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/me", wrapper.Whoami)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}", wrapper.DeleteUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}", wrapper.FindUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}", wrapper.UpdateUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/policies", wrapper.FindPoliciesForUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}/rate", wrapper.SetRequestRateForUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.FindTokensForUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.AddNewTokenToUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}/tokens/{token_uuid}", wrapper.DeleteTokenForUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
