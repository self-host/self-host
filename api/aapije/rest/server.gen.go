// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get alerts. TBD
	// (GET /v2/alerts)
	FindAlerts(w http.ResponseWriter, r *http.Request, params FindAlertsParams)
	// Get datasets.
	// (GET /v2/datasets)
	FindDatasets(w http.ResponseWriter, r *http.Request, params FindDatasetsParams)
	// Add dataset.
	// (POST /v2/datasets)
	AddDatasets(w http.ResponseWriter, r *http.Request)
	// Delete a specific dataset.
	// (DELETE /v2/datasets/{uuid})
	DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get a specific dataset.
	// (GET /v2/datasets/{uuid})
	FindDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a specific dataset.
	// (PUT /v2/datasets/{uuid})
	UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Assemble the uploaded parts. TBD.
	// (POST /v2/datasets/{uuid}/assemble)
	AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AssembleDatasetPartsByKeyParams)
	// List parts. TBD.
	// (GET /v2/datasets/{uuid}/parts)
	ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params ListDatasetPartsByKeyParams)
	// Upload each part of the data-set content. TBD.
	// (PUT /v2/datasets/{uuid}/parts)
	UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params UploadDatasetContentByKeyParams)
	// Download dataset content
	// (GET /v2/datasets/{uuid}/raw)
	GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetRawDatasetByUuidParams)
	// Cancel content upload. TBD.
	// (DELETE /v2/datasets/{uuid}/uploads)
	DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDatasetUploadByKeyParams)
	// Initialize a content upload. TBD.
	// (POST /v2/datasets/{uuid}/uploads)
	InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get groups.
	// (GET /v2/groups)
	FindGroups(w http.ResponseWriter, r *http.Request, params FindGroupsParams)
	// Add a new group.
	// (POST /v2/groups)
	AddGroup(w http.ResponseWriter, r *http.Request)
	// Delete a Group
	// (DELETE /v2/groups/{uuid})
	DeleteGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get info about a Group
	// (GET /v2/groups/{uuid})
	FindGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a Group
	// (PUT /v2/groups/{uuid})
	UpdateGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies for a Group
	// (GET /v2/groups/{uuid}/policies)
	FindPoliciesForGroup(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies
	// (GET /v2/policies)
	FindPolicies(w http.ResponseWriter, r *http.Request, params FindPoliciesParams)
	// Add a new Policy
	// (POST /v2/policies)
	AddPolicy(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/policies/{uuid})
	DeletePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/policies/{uuid})
	FindPolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/policies/{uuid})
	UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs)
	FindPrograms(w http.ResponseWriter, r *http.Request, params FindProgramsParams)

	// (POST /v2/programs)
	AddProgram(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/programs/{uuid})
	DeleteProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid})
	FindProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/programs/{uuid})
	UpdateProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/code)
	GetCodeFromProgram(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (POST /v2/programs/{uuid}/code)
	AddProgramCodeRevision(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/diff)
	GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetProgramCodeRevisionsDiffParams)

	// (GET /v2/programs/{uuid}/revisions)
	GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (DELETE /v2/programs/{uuid}/revisions/{revision_id})
	DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)

	// (PUT /v2/programs/{uuid}/revisions/{revision_id}/sign)
	SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)
	// TBD
	// (POST /v2/programs/{uuid}/webhook)
	ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things)
	FindThings(w http.ResponseWriter, r *http.Request, params FindThingsParams)

	// (POST /v2/things)
	AddThing(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/things/{uuid})
	DeleteThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things/{uuid})
	FindThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Thing.
	// (PUT /v2/things/{uuid})
	UpdateThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Datasets assigned to a Thing.
	// (GET /v2/things/{uuid}/datasets)
	FindDatasetsForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Timeseries assigned to a Thing.
	// (GET /v2/things/{uuid}/timeseries)
	FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries)
	FindTimeSeries(w http.ResponseWriter, r *http.Request, params FindTimeSeriesParams)

	// (POST /v2/timeseries)
	AddTimeSeries(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/timeseries/{uuid})
	DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries/{uuid})
	FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Timeseries.
	// (PUT /v2/timeseries/{uuid})
	UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete a range of Timeseries data.
	// (DELETE /v2/timeseries/{uuid}/data)
	DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDataFromTimeSeriesParams)
	// Get a range of Timeseries data.
	// (GET /v2/timeseries/{uuid}/data)
	QueryTimeseriesForData(w http.ResponseWriter, r *http.Request, uuid UuidParam, params QueryTimeseriesForDataParams)
	// Add data to Timeseries
	// (POST /v2/timeseries/{uuid}/data)
	AddDataToTimeseries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AddDataToTimeseriesParams)
	// Query for data from Time series.
	// (GET /v2/tsquery)
	FindTsdataByQuery(w http.ResponseWriter, r *http.Request, params FindTsdataByQueryParams)
	// Returns a list of user objects.
	// (GET /v2/users)
	FindUsers(w http.ResponseWriter, r *http.Request, params FindUsersParams)

	// (POST /v2/users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Who am I
	// (GET /v2/users/me)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Delete a User
	// (DELETE /v2/users/{uuid})
	DeleteUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid})
	FindUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a User
	// (PUT /v2/users/{uuid})
	UpdateUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid}/policies)
	FindPoliciesForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// TBD
	// (PUT /v2/users/{uuid}/rate)
	SetRequestRateForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Access tokens
	// (GET /v2/users/{uuid}/tokens)
	FindTokensForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Generate a new access token.
	// (POST /v2/users/{uuid}/tokens)
	AddNewTokenToUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete access token.
	// (DELETE /v2/users/{uuid}/tokens/{token_uuid})
	DeleteTokenForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam, tokenUuid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// FindAlerts operation middleware
func (siw *ServerInterfaceWrapper) FindAlerts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:alerts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAlertsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAlerts(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasets operation middleware
func (siw *ServerInterfaceWrapper) FindDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindDatasetsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasets(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDatasets operation middleware
func (siw *ServerInterfaceWrapper) AddDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDatasets(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AssembleDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssembleDatasetPartsByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssembleDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDatasetPartsByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadDatasetContentByKey operation middleware
func (siw *ServerInterfaceWrapper) UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadDatasetContentByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDatasetContentByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRawDatasetByUuidParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchParam
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawDatasetByUuid(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetUploadByKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDatasetUploadByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetUploadByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InitializeDatasetUploadByUuid operation middleware
func (siw *ServerInterfaceWrapper) InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitializeDatasetUploadByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroups operation middleware
func (siw *ServerInterfaceWrapper) FindGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroup operation middleware
func (siw *ServerInterfaceWrapper) AddGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:groups"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForGroup operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForGroup(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicies operation middleware
func (siw *ServerInterfaceWrapper) FindPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPoliciesParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_uuids" -------------
	if paramValue := r.URL.Query().Get("group_uuids"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "group_uuids", r.URL.Query(), &params.GroupUuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter group_uuids: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddPolicy operation middleware
func (siw *ServerInterfaceWrapper) AddPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPolicy(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindPolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPrograms operation middleware
func (siw *ServerInterfaceWrapper) FindPrograms(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindProgramsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPrograms(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgram operation middleware
func (siw *ServerInterfaceWrapper) AddProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgram(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCodeFromProgram operation middleware
func (siw *ServerInterfaceWrapper) GetCodeFromProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCodeFromProgram(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgramCodeRevision operation middleware
func (siw *ServerInterfaceWrapper) AddProgramCodeRevision(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgramCodeRevision(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisionsDiff operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions/diff"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramCodeRevisionsDiffParams

	// ------------- Required query parameter "rev_a" -------------
	if paramValue := r.URL.Query().Get("rev_a"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_a is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_a", r.URL.Query(), &params.RevA)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_a: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "rev_b" -------------
	if paramValue := r.URL.Query().Get("rev_b"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_b is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_b", r.URL.Query(), &params.RevB)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_b: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisionsDiff(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisions(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExecuteProgramWebhook operation middleware
func (siw *ServerInterfaceWrapper) ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/webhook"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteProgramWebhook(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThings operation middleware
func (siw *ServerInterfaceWrapper) FindThings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindThingsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThings(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddThing operation middleware
func (siw *ServerInterfaceWrapper) AddThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:things"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddThing(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetsForThing operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetsForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}/datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetsForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesForThing operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTimeSeriesParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeries(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) AddTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimeSeries(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTimeseriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimeseriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDataFromTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDataFromTimeSeriesParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDataFromTimeSeries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// QueryTimeseriesForData operation middleware
func (siw *ServerInterfaceWrapper) QueryTimeseriesForData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTimeseriesForDataParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTimeseriesForData(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDataToTimeseries operation middleware
func (siw *ServerInterfaceWrapper) AddDataToTimeseries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddDataToTimeseriesParams

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDataToTimeseries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTsdataByQuery operation middleware
func (siw *ServerInterfaceWrapper) FindTsdataByQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:tsquery"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTsdataByQueryParams

	// ------------- Required query parameter "uuids" -------------
	if paramValue := r.URL.Query().Get("uuids"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uuids is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuids", r.URL.Query(), &params.Uuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuids: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTsdataByQuery(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUsers operation middleware
func (siw *ServerInterfaceWrapper) FindUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUsersParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/me"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForUser operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRequestRateForUser operation middleware
func (siw *ServerInterfaceWrapper) SetRequestRateForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}/rate"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRequestRateForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTokensForUser operation middleware
func (siw *ServerInterfaceWrapper) FindTokensForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTokensForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddNewTokenToUser operation middleware
func (siw *ServerInterfaceWrapper) AddNewTokenToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddNewTokenToUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTokenForUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteTokenForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "token_uuid" -------------
	var tokenUuid string

	err = runtime.BindStyledParameter("simple", false, "token_uuid", chi.URLParam(r, "token_uuid"), &tokenUuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter token_uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}/tokens/{token_uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTokenForUser(w, r, uuid, tokenUuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/alerts", wrapper.FindAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets", wrapper.FindDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets", wrapper.AddDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}", wrapper.DeleteDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}", wrapper.FindDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}", wrapper.UpdateDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/assemble", wrapper.AssembleDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.ListDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.UploadDatasetContentByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/raw", wrapper.GetRawDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.DeleteDatasetUploadByKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.InitializeDatasetUploadByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups", wrapper.FindGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/groups", wrapper.AddGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/groups/{uuid}", wrapper.DeleteGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}", wrapper.FindGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/groups/{uuid}", wrapper.UpdateGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}/policies", wrapper.FindPoliciesForGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies", wrapper.FindPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/policies", wrapper.AddPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/policies/{uuid}", wrapper.DeletePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies/{uuid}", wrapper.FindPolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/policies/{uuid}", wrapper.UpdatePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs", wrapper.FindPrograms)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs", wrapper.AddProgram)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}", wrapper.DeleteProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}", wrapper.FindProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}", wrapper.UpdateProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.GetCodeFromProgram)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.AddProgramCodeRevision)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/diff", wrapper.GetProgramCodeRevisionsDiff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/revisions", wrapper.GetProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}", wrapper.DeleteProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}/sign", wrapper.SignProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/webhook", wrapper.ExecuteProgramWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things", wrapper.FindThings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/things", wrapper.AddThing)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/things/{uuid}", wrapper.DeleteThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}", wrapper.FindThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/things/{uuid}", wrapper.UpdateThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/datasets", wrapper.FindDatasetsForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/timeseries", wrapper.FindTimeSeriesForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries", wrapper.FindTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries", wrapper.AddTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.DeleteTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.FindTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.UpdateTimeseriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.DeleteDataFromTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.QueryTimeseriesForData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.AddDataToTimeseries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/tsquery", wrapper.FindTsdataByQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users", wrapper.FindUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/me", wrapper.Whoami)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}", wrapper.DeleteUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}", wrapper.FindUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}", wrapper.UpdateUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/policies", wrapper.FindPoliciesForUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}/rate", wrapper.SetRequestRateForUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.FindTokensForUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.AddNewTokenToUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}/tokens/{token_uuid}", wrapper.DeleteTokenForUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
