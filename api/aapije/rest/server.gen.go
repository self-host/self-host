// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get alerts. TBD
	// (GET /v2/alerts)
	FindAlerts(w http.ResponseWriter, r *http.Request, params FindAlertsParams)
	// Get datasets.
	// (GET /v2/datasets)
	FindDatasets(w http.ResponseWriter, r *http.Request, params FindDatasetsParams)
	// Add dataset.
	// (POST /v2/datasets)
	AddDatasets(w http.ResponseWriter, r *http.Request)
	// Delete a specific dataset.
	// (DELETE /v2/datasets/{uuid})
	DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get a specific dataset.
	// (GET /v2/datasets/{uuid})
	FindDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a specific dataset.
	// (PUT /v2/datasets/{uuid})
	UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Assemble the uploaded parts. TBD.
	// (POST /v2/datasets/{uuid}/assemble)
	AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AssembleDatasetPartsByKeyParams)
	// List parts. TBD.
	// (GET /v2/datasets/{uuid}/parts)
	ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params ListDatasetPartsByKeyParams)
	// Upload each part of the data-set content. TBD.
	// (PUT /v2/datasets/{uuid}/parts)
	UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params UploadDatasetContentByKeyParams)
	// Download dataset content
	// (GET /v2/datasets/{uuid}/raw)
	GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetRawDatasetByUuidParams)
	// Cancel content upload. TBD.
	// (DELETE /v2/datasets/{uuid}/uploads)
	DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDatasetUploadByKeyParams)
	// Initialize a content upload. TBD.
	// (POST /v2/datasets/{uuid}/uploads)
	InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get groups.
	// (GET /v2/groups)
	FindGroups(w http.ResponseWriter, r *http.Request, params FindGroupsParams)
	// Add a new group.
	// (POST /v2/groups)
	AddGroup(w http.ResponseWriter, r *http.Request)
	// Delete a Group
	// (DELETE /v2/groups/{uuid})
	DeleteGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get info about a Group
	// (GET /v2/groups/{uuid})
	FindGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a Group
	// (PUT /v2/groups/{uuid})
	UpdateGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies for a Group
	// (GET /v2/groups/{uuid}/policies)
	FindPoliciesForGroup(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies
	// (GET /v2/policies)
	FindPolicies(w http.ResponseWriter, r *http.Request, params FindPoliciesParams)
	// Add a new Policy
	// (POST /v2/policies)
	AddPolicy(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/policies/{uuid})
	DeletePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/policies/{uuid})
	FindPolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/policies/{uuid})
	UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs)
	FindPrograms(w http.ResponseWriter, r *http.Request, params FindProgramsParams)

	// (POST /v2/programs)
	AddProgram(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/programs/{uuid})
	DeleteProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid})
	FindProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/programs/{uuid})
	UpdateProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/code)
	GetCodeFromProgram(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (POST /v2/programs/{uuid}/code)
	AddProgramCodeRevision(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/diff)
	GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetProgramCodeRevisionsDiffParams)

	// (GET /v2/programs/{uuid}/revisions)
	GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (DELETE /v2/programs/{uuid}/revisions/{revision_id})
	DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)

	// (PUT /v2/programs/{uuid}/revisions/{revision_id}/sign)
	SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)
	// TBD
	// (POST /v2/programs/{uuid}/webhook)
	ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things)
	FindThings(w http.ResponseWriter, r *http.Request, params FindThingsParams)

	// (POST /v2/things)
	AddThing(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/things/{uuid})
	DeleteThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things/{uuid})
	FindThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Thing.
	// (PUT /v2/things/{uuid})
	UpdateThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Datasets assigned to a Thing.
	// (GET /v2/things/{uuid}/datasets)
	FindDatasetsForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Timeseries assigned to a Thing.
	// (GET /v2/things/{uuid}/timeseries)
	FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries)
	FindTimeSeries(w http.ResponseWriter, r *http.Request, params FindTimeSeriesParams)

	// (POST /v2/timeseries)
	AddTimeSeries(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/timeseries/{uuid})
	DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries/{uuid})
	FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Timeseries.
	// (PUT /v2/timeseries/{uuid})
	UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete a range of Timeseries data.
	// (DELETE /v2/timeseries/{uuid}/data)
	DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDataFromTimeSeriesParams)
	// Get a range of Timeseries data.
	// (GET /v2/timeseries/{uuid}/data)
	QueryTimeseriesForData(w http.ResponseWriter, r *http.Request, uuid UuidParam, params QueryTimeseriesForDataParams)
	// Add data to Timeseries
	// (POST /v2/timeseries/{uuid}/data)
	AddDataToTimeseries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AddDataToTimeseriesParams)
	// Query for data from Time series.
	// (GET /v2/tsquery)
	FindTsdataByQuery(w http.ResponseWriter, r *http.Request, params FindTsdataByQueryParams)
	// Returns a list of user objects.
	// (GET /v2/users)
	FindUsers(w http.ResponseWriter, r *http.Request, params FindUsersParams)

	// (POST /v2/users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Who am I
	// (GET /v2/users/me)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Delete a User
	// (DELETE /v2/users/{uuid})
	DeleteUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid})
	FindUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a User
	// (PUT /v2/users/{uuid})
	UpdateUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid}/policies)
	FindPoliciesForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// TBD
	// (PUT /v2/users/{uuid}/rate)
	SetRequestRateForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Access tokens
	// (GET /v2/users/{uuid}/tokens)
	FindTokensForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Generate a new access token.
	// (POST /v2/users/{uuid}/tokens)
	AddNewTokenToUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete access token.
	// (DELETE /v2/users/{uuid}/tokens/{token_uuid})
	DeleteTokenForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam, tokenUuid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// FindAlerts operation middleware
func (siw *ServerInterfaceWrapper) FindAlerts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:alerts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAlertsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAlerts(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasets operation middleware
func (siw *ServerInterfaceWrapper) FindDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindDatasetsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasets(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDatasets operation middleware
func (siw *ServerInterfaceWrapper) AddDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDatasets(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AssembleDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssembleDatasetPartsByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssembleDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDatasetPartsByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadDatasetContentByKey operation middleware
func (siw *ServerInterfaceWrapper) UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadDatasetContentByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDatasetContentByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRawDatasetByUuidParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatchParam
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawDatasetByUuid(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetUploadByKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDatasetUploadByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetUploadByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InitializeDatasetUploadByUuid operation middleware
func (siw *ServerInterfaceWrapper) InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitializeDatasetUploadByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroups operation middleware
func (siw *ServerInterfaceWrapper) FindGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroup operation middleware
func (siw *ServerInterfaceWrapper) AddGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:groups"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForGroup operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForGroup(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicies operation middleware
func (siw *ServerInterfaceWrapper) FindPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPoliciesParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_uuids" -------------
	if paramValue := r.URL.Query().Get("group_uuids"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "group_uuids", r.URL.Query(), &params.GroupUuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter group_uuids: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddPolicy operation middleware
func (siw *ServerInterfaceWrapper) AddPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPolicy(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindPolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPrograms operation middleware
func (siw *ServerInterfaceWrapper) FindPrograms(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindProgramsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPrograms(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgram operation middleware
func (siw *ServerInterfaceWrapper) AddProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgram(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCodeFromProgram operation middleware
func (siw *ServerInterfaceWrapper) GetCodeFromProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCodeFromProgram(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgramCodeRevision operation middleware
func (siw *ServerInterfaceWrapper) AddProgramCodeRevision(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgramCodeRevision(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisionsDiff operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions/diff"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramCodeRevisionsDiffParams

	// ------------- Required query parameter "rev_a" -------------
	if paramValue := r.URL.Query().Get("rev_a"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_a is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_a", r.URL.Query(), &params.RevA)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_a: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "rev_b" -------------
	if paramValue := r.URL.Query().Get("rev_b"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_b is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_b", r.URL.Query(), &params.RevB)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_b: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisionsDiff(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisions(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExecuteProgramWebhook operation middleware
func (siw *ServerInterfaceWrapper) ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/webhook"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteProgramWebhook(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThings operation middleware
func (siw *ServerInterfaceWrapper) FindThings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindThingsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThings(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddThing operation middleware
func (siw *ServerInterfaceWrapper) AddThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:things"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddThing(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetsForThing operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetsForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}/datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetsForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesForThing operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTimeSeriesParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeries(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) AddTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimeSeries(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTimeseriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimeseriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDataFromTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDataFromTimeSeriesParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDataFromTimeSeries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// QueryTimeseriesForData operation middleware
func (siw *ServerInterfaceWrapper) QueryTimeseriesForData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTimeseriesForDataParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTimeseriesForData(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDataToTimeseries operation middleware
func (siw *ServerInterfaceWrapper) AddDataToTimeseries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddDataToTimeseriesParams

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDataToTimeseries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTsdataByQuery operation middleware
func (siw *ServerInterfaceWrapper) FindTsdataByQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:tsquery"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTsdataByQueryParams

	// ------------- Required query parameter "uuids" -------------
	if paramValue := r.URL.Query().Get("uuids"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uuids is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uuids", r.URL.Query(), &params.Uuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuids: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "precision" -------------
	if paramValue := r.URL.Query().Get("precision"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "precision", r.URL.Query(), &params.Precision)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter precision: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "aggregate" -------------
	if paramValue := r.URL.Query().Get("aggregate"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "aggregate", r.URL.Query(), &params.Aggregate)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter aggregate: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "timezone" -------------
	if paramValue := r.URL.Query().Get("timezone"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "timezone", r.URL.Query(), &params.Timezone)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter timezone: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTsdataByQuery(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUsers operation middleware
func (siw *ServerInterfaceWrapper) FindUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUsersParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/me"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForUser operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRequestRateForUser operation middleware
func (siw *ServerInterfaceWrapper) SetRequestRateForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}/rate"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRequestRateForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTokensForUser operation middleware
func (siw *ServerInterfaceWrapper) FindTokensForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTokensForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddNewTokenToUser operation middleware
func (siw *ServerInterfaceWrapper) AddNewTokenToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddNewTokenToUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTokenForUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteTokenForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "token_uuid" -------------
	var tokenUuid string

	err = runtime.BindStyledParameter("simple", false, "token_uuid", chi.URLParam(r, "token_uuid"), &tokenUuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter token_uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}/tokens/{token_uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTokenForUser(w, r, uuid, tokenUuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/alerts", wrapper.FindAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets", wrapper.FindDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets", wrapper.AddDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}", wrapper.DeleteDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}", wrapper.FindDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}", wrapper.UpdateDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/assemble", wrapper.AssembleDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.ListDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.UploadDatasetContentByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/raw", wrapper.GetRawDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.DeleteDatasetUploadByKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.InitializeDatasetUploadByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups", wrapper.FindGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/groups", wrapper.AddGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/groups/{uuid}", wrapper.DeleteGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}", wrapper.FindGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/groups/{uuid}", wrapper.UpdateGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}/policies", wrapper.FindPoliciesForGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies", wrapper.FindPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/policies", wrapper.AddPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/policies/{uuid}", wrapper.DeletePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies/{uuid}", wrapper.FindPolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/policies/{uuid}", wrapper.UpdatePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs", wrapper.FindPrograms)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs", wrapper.AddProgram)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}", wrapper.DeleteProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}", wrapper.FindProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}", wrapper.UpdateProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.GetCodeFromProgram)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.AddProgramCodeRevision)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/diff", wrapper.GetProgramCodeRevisionsDiff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/revisions", wrapper.GetProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}", wrapper.DeleteProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}/sign", wrapper.SignProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/webhook", wrapper.ExecuteProgramWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things", wrapper.FindThings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/things", wrapper.AddThing)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/things/{uuid}", wrapper.DeleteThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}", wrapper.FindThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/things/{uuid}", wrapper.UpdateThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/datasets", wrapper.FindDatasetsForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/timeseries", wrapper.FindTimeSeriesForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries", wrapper.FindTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries", wrapper.AddTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.DeleteTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.FindTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.UpdateTimeseriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.DeleteDataFromTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.QueryTimeseriesForData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.AddDataToTimeseries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/tsquery", wrapper.FindTsdataByQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users", wrapper.FindUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/me", wrapper.Whoami)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}", wrapper.DeleteUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}", wrapper.FindUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}", wrapper.UpdateUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/policies", wrapper.FindPoliciesForUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}/rate", wrapper.SetRequestRateForUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.FindTokensForUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.AddNewTokenToUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}/tokens/{token_uuid}", wrapper.DeleteTokenForUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
