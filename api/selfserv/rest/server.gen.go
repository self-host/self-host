// Package rest provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package rest

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get alerts. TBD
	// (GET /v2/alerts)
	FindAlerts(w http.ResponseWriter, r *http.Request, params FindAlertsParams)
	// Get datasets.
	// (GET /v2/datasets)
	FindDatasets(w http.ResponseWriter, r *http.Request, params FindDatasetsParams)
	// Add dataset.
	// (POST /v2/datasets)
	AddDatasets(w http.ResponseWriter, r *http.Request)
	// Delete a specific dataset.
	// (DELETE /v2/datasets/{uuid})
	DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get a specific dataset.
	// (GET /v2/datasets/{uuid})
	FindDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a specific dataset.
	// (PUT /v2/datasets/{uuid})
	UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Assemble the uploaded parts. TBD.
	// (POST /v2/datasets/{uuid}/assemble)
	AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AssembleDatasetPartsByKeyParams)
	// List parts. TBD.
	// (GET /v2/datasets/{uuid}/parts)
	ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params ListDatasetPartsByKeyParams)
	// Upload each part of the data-set content. TBD.
	// (PUT /v2/datasets/{uuid}/parts)
	UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params UploadDatasetContentByKeyParams)
	// Download dataset content
	// (GET /v2/datasets/{uuid}/raw)
	GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Cancel content upload. TBD.
	// (DELETE /v2/datasets/{uuid}/uploads)
	DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDatasetUploadByKeyParams)
	// Initialize a content upload. TBD.
	// (POST /v2/datasets/{uuid}/uploads)
	InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get groups.
	// (GET /v2/groups)
	FindGroups(w http.ResponseWriter, r *http.Request, params FindGroupsParams)
	// Add a new group.
	// (POST /v2/groups)
	AddGroup(w http.ResponseWriter, r *http.Request)
	// Delete a Group
	// (DELETE /v2/groups/{uuid})
	DeleteGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Get info about a Group
	// (GET /v2/groups/{uuid})
	FindGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a Group
	// (PUT /v2/groups/{uuid})
	UpdateGroupByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies for a Group
	// (GET /v2/groups/{uuid}/policies)
	FindPoliciesForGroup(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Policies
	// (GET /v2/policies)
	FindPolicies(w http.ResponseWriter, r *http.Request, params FindPoliciesParams)
	// Add a new Policy
	// (POST /v2/policies)
	AddPolicy(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/policies/{uuid})
	DeletePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/policies/{uuid})
	FindPolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/policies/{uuid})
	UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs)
	FindPrograms(w http.ResponseWriter, r *http.Request, params FindProgramsParams)

	// (POST /v2/programs)
	AddProgram(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/programs/{uuid})
	DeleteProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid})
	FindProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (PUT /v2/programs/{uuid})
	UpdateProgramByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/code)
	GetCodeFromProgram(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (POST /v2/programs/{uuid}/code)
	AddProgramCodeRevision(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/programs/{uuid}/diff)
	GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request, uuid UuidParam, params GetProgramCodeRevisionsDiffParams)

	// (GET /v2/programs/{uuid}/revisions)
	GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (DELETE /v2/programs/{uuid}/revisions/{revision_id})
	DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)

	// (PUT /v2/programs/{uuid}/revisions/{revision_id}/sign)
	SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request, uuid UuidParam, revisionId int)
	// TBD
	// (POST /v2/programs/{uuid}/webhook)
	ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things)
	FindThings(w http.ResponseWriter, r *http.Request, params FindThingsParams)

	// (POST /v2/things)
	AddThing(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/things/{uuid})
	DeleteThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/things/{uuid})
	FindThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Thing.
	// (PUT /v2/things/{uuid})
	UpdateThingByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Datasets assigned to a Thing.
	// (GET /v2/things/{uuid}/datasets)
	FindDatasetsForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// List Timeseries assigned to a Thing.
	// (GET /v2/things/{uuid}/timeseries)
	FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries)
	FindTimeSeries(w http.ResponseWriter, r *http.Request, params FindTimeSeriesParams)

	// (POST /v2/timeseries)
	AddTimeSeries(w http.ResponseWriter, r *http.Request)

	// (DELETE /v2/timeseries/{uuid})
	DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/timeseries/{uuid})
	FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update Timeseries.
	// (PUT /v2/timeseries/{uuid})
	UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete a range of Timeseries data.
	// (DELETE /v2/timeseries/{uuid}/data)
	DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params DeleteDataFromTimeSeriesParams)
	// Get a range of Timeseries data.
	// (GET /v2/timeseries/{uuid}/data)
	QueryTimeseriesForData(w http.ResponseWriter, r *http.Request, uuid UuidParam, params QueryTimeseriesForDataParams)
	// Add data to Timeseries
	// (POST /v2/timeseries/{uuid}/data)
	AddDataToTimeseries(w http.ResponseWriter, r *http.Request, uuid UuidParam, params AddDataToTimeseriesParams)
	// Query for data from Time series. TBD.
	// (GET /v2/tsquery)
	FindTsdataByQuery(w http.ResponseWriter, r *http.Request)
	// Returns a list of user objects.
	// (GET /v2/users)
	FindUsers(w http.ResponseWriter, r *http.Request, params FindUsersParams)

	// (POST /v2/users)
	AddUser(w http.ResponseWriter, r *http.Request)
	// Who am I
	// (GET /v2/users/me)
	Whoami(w http.ResponseWriter, r *http.Request)
	// Delete a User
	// (DELETE /v2/users/{uuid})
	DeleteUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid})
	FindUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Update a User
	// (PUT /v2/users/{uuid})
	UpdateUserByUuid(w http.ResponseWriter, r *http.Request, uuid UuidParam)

	// (GET /v2/users/{uuid}/policies)
	FindPoliciesForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// TBD
	// (PUT /v2/users/{uuid}/rate)
	SetRequestRateForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Access tokens
	// (GET /v2/users/{uuid}/tokens)
	FindTokensForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Generate a new access token.
	// (POST /v2/users/{uuid}/tokens)
	AddNewTokenToUser(w http.ResponseWriter, r *http.Request, uuid UuidParam)
	// Delete access token.
	// (DELETE /v2/users/{uuid}/tokens/{token_uuid})
	DeleteTokenForUser(w http.ResponseWriter, r *http.Request, uuid UuidParam, tokenUuid string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// FindAlerts operation middleware
func (siw *ServerInterfaceWrapper) FindAlerts(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:alerts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAlertsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAlerts(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasets operation middleware
func (siw *ServerInterfaceWrapper) FindDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindDatasetsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasets(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDatasets operation middleware
func (siw *ServerInterfaceWrapper) AddDatasets(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDatasets(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AssembleDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) AssembleDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssembleDatasetPartsByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AssembleDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListDatasetPartsByKey operation middleware
func (siw *ServerInterfaceWrapper) ListDatasetPartsByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDatasetPartsByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatasetPartsByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadDatasetContentByKey operation middleware
func (siw *ServerInterfaceWrapper) UploadDatasetContentByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadDatasetContentByKeyParams

	// ------------- Required query parameter "partNumber" -------------
	if paramValue := r.URL.Query().Get("partNumber"); paramValue != "" {

	} else {
		http.Error(w, "Query argument partNumber is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "partNumber", r.URL.Query(), &params.PartNumber)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter partNumber: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "uploadId" -------------
	if paramValue := r.URL.Query().Get("uploadId"); paramValue != "" {

	} else {
		http.Error(w, "Query argument uploadId is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "uploadId", r.URL.Query(), &params.UploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Content-MD5" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Content-MD5")]; found {
		var ContentMD5 string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Content-MD5, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Content-MD5", valueList[0], &ContentMD5)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Content-MD5: %s", err), http.StatusBadRequest)
			return
		}

		params.ContentMD5 = ContentMD5

	} else {
		http.Error(w, fmt.Sprintf("Header parameter Content-MD5 is required, but not found: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDatasetContentByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRawDatasetByUuid operation middleware
func (siw *ServerInterfaceWrapper) GetRawDatasetByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRawDatasetByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDatasetUploadByKey operation middleware
func (siw *ServerInterfaceWrapper) DeleteDatasetUploadByKey(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:datasets/{uuid}"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDatasetUploadByKeyParams

	// ------------- Required query parameter "key" -------------
	if paramValue := r.URL.Query().Get("key"); paramValue != "" {

	} else {
		http.Error(w, "Query argument key is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "key", r.URL.Query(), &params.Key)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter key: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDatasetUploadByKey(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InitializeDatasetUploadByUuid operation middleware
func (siw *ServerInterfaceWrapper) InitializeDatasetUploadByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:datasets/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InitializeDatasetUploadByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroups operation middleware
func (siw *ServerInterfaceWrapper) FindGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindGroupsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroup operation middleware
func (siw *ServerInterfaceWrapper) AddGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:groups"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroup(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateGroupByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateGroupByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateGroupByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForGroup operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:groups/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForGroup(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicies operation middleware
func (siw *ServerInterfaceWrapper) FindPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindPoliciesParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "group_uuids" -------------
	if paramValue := r.URL.Query().Get("group_uuids"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "group_uuids", r.URL.Query(), &params.GroupUuids)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter group_uuids: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddPolicy operation middleware
func (siw *ServerInterfaceWrapper) AddPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddPolicy(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindPolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicyByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicyByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:policies/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicyByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPrograms operation middleware
func (siw *ServerInterfaceWrapper) FindPrograms(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindProgramsParams

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPrograms(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgram operation middleware
func (siw *ServerInterfaceWrapper) AddProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgram(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateProgramByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateProgramByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateProgramByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCodeFromProgram operation middleware
func (siw *ServerInterfaceWrapper) GetCodeFromProgram(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCodeFromProgram(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddProgramCodeRevision operation middleware
func (siw *ServerInterfaceWrapper) AddProgramCodeRevision(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/code"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddProgramCodeRevision(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisionsDiff operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisionsDiff(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions/diff"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProgramCodeRevisionsDiffParams

	// ------------- Required query parameter "rev_a" -------------
	if paramValue := r.URL.Query().Get("rev_a"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_a is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_a", r.URL.Query(), &params.RevA)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_a: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "rev_b" -------------
	if paramValue := r.URL.Query().Get("rev_b"); paramValue != "" {

	} else {
		http.Error(w, "Query argument rev_b is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "rev_b", r.URL.Query(), &params.RevB)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rev_b: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisionsDiff(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) GetProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:programs/{uuid}/revisions"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetProgramCodeRevisions(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) DeleteProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SignProgramCodeRevisions operation middleware
func (siw *ServerInterfaceWrapper) SignProgramCodeRevisions(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "revision_id" -------------
	var revisionId int

	err = runtime.BindStyledParameter("simple", false, "revision_id", chi.URLParam(r, "revision_id"), &revisionId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter revision_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:programs/{uuid}/revisions/{revision_id}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignProgramCodeRevisions(w, r, uuid, revisionId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ExecuteProgramWebhook operation middleware
func (siw *ServerInterfaceWrapper) ExecuteProgramWebhook(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:programs/{uuid}/webhook"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExecuteProgramWebhook(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThings operation middleware
func (siw *ServerInterfaceWrapper) FindThings(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindThingsParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThings(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddThing operation middleware
func (siw *ServerInterfaceWrapper) AddThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:things"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddThing(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateThingByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateThingByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateThingByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindDatasetsForThing operation middleware
func (siw *ServerInterfaceWrapper) FindDatasetsForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}/datasets"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindDatasetsForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesForThing operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesForThing(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:things/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesForThing(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindTimeSeriesParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "tags" -------------
	if paramValue := r.URL.Query().Get("tags"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tags", r.URL.Query(), &params.Tags)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tags: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeries(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) AddTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddTimeSeries(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTimeSeriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindTimeSeriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTimeSeriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateTimeseriesByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateTimeseriesByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:timeseries/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateTimeseriesByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteDataFromTimeSeries operation middleware
func (siw *ServerInterfaceWrapper) DeleteDataFromTimeSeries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteDataFromTimeSeriesParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDataFromTimeSeries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// QueryTimeseriesForData operation middleware
func (siw *ServerInterfaceWrapper) QueryTimeseriesForData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTimeseriesForDataParams

	// ------------- Required query parameter "start" -------------
	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		http.Error(w, "Query argument start is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter start: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "end" -------------
	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		http.Error(w, "Query argument end is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter end: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "ge" -------------
	if paramValue := r.URL.Query().Get("ge"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "ge", r.URL.Query(), &params.Ge)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ge: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "le" -------------
	if paramValue := r.URL.Query().Get("le"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "le", r.URL.Query(), &params.Le)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter le: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTimeseriesForData(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddDataToTimeseries operation middleware
func (siw *ServerInterfaceWrapper) AddDataToTimeseries(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:timeseries/{uuid}/data"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddDataToTimeseriesParams

	// ------------- Optional query parameter "unit" -------------
	if paramValue := r.URL.Query().Get("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", r.URL.Query(), &params.Unit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter unit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddDataToTimeseries(w, r, uuid, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTsdataByQuery operation middleware
func (siw *ServerInterfaceWrapper) FindTsdataByQuery(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:tsquery"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTsdataByQuery(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUsers operation middleware
func (siw *ServerInterfaceWrapper) FindUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params FindUsersParams

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter offset: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddUser operation middleware
func (siw *ServerInterfaceWrapper) AddUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Whoami operation middleware
func (siw *ServerInterfaceWrapper) Whoami(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/me"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Whoami(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) FindUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdateUserByUuid operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserByUuid(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserByUuid(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindPoliciesForUser operation middleware
func (siw *ServerInterfaceWrapper) FindPoliciesForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/policies"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindPoliciesForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRequestRateForUser operation middleware
func (siw *ServerInterfaceWrapper) SetRequestRateForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"update:users/{uuid}/rate"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRequestRateForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindTokensForUser operation middleware
func (siw *ServerInterfaceWrapper) FindTokensForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"read:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindTokensForUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddNewTokenToUser operation middleware
func (siw *ServerInterfaceWrapper) AddNewTokenToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"create:users/{uuid}/tokens"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddNewTokenToUser(w, r, uuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTokenForUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteTokenForUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid UuidParam

	err = runtime.BindStyledParameter("simple", false, "uuid", chi.URLParam(r, "uuid"), &uuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uuid: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "token_uuid" -------------
	var tokenUuid string

	err = runtime.BindStyledParameter("simple", false, "token_uuid", chi.URLParam(r, "token_uuid"), &tokenUuid)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter token_uuid: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BasicAuthScopes, []string{"delete:users/{uuid}/tokens/{token_uuid}"})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTokenForUser(w, r, uuid, tokenUuid)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/alerts", wrapper.FindAlerts)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets", wrapper.FindDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets", wrapper.AddDatasets)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}", wrapper.DeleteDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}", wrapper.FindDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}", wrapper.UpdateDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/assemble", wrapper.AssembleDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.ListDatasetPartsByKey)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/datasets/{uuid}/parts", wrapper.UploadDatasetContentByKey)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/datasets/{uuid}/raw", wrapper.GetRawDatasetByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.DeleteDatasetUploadByKey)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/datasets/{uuid}/uploads", wrapper.InitializeDatasetUploadByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups", wrapper.FindGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/groups", wrapper.AddGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/groups/{uuid}", wrapper.DeleteGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}", wrapper.FindGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/groups/{uuid}", wrapper.UpdateGroupByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/groups/{uuid}/policies", wrapper.FindPoliciesForGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies", wrapper.FindPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/policies", wrapper.AddPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/policies/{uuid}", wrapper.DeletePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/policies/{uuid}", wrapper.FindPolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/policies/{uuid}", wrapper.UpdatePolicyByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs", wrapper.FindPrograms)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs", wrapper.AddProgram)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}", wrapper.DeleteProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}", wrapper.FindProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}", wrapper.UpdateProgramByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.GetCodeFromProgram)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/code", wrapper.AddProgramCodeRevision)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/diff", wrapper.GetProgramCodeRevisionsDiff)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/programs/{uuid}/revisions", wrapper.GetProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}", wrapper.DeleteProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/programs/{uuid}/revisions/{revision_id}/sign", wrapper.SignProgramCodeRevisions)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/programs/{uuid}/webhook", wrapper.ExecuteProgramWebhook)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things", wrapper.FindThings)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/things", wrapper.AddThing)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/things/{uuid}", wrapper.DeleteThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}", wrapper.FindThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/things/{uuid}", wrapper.UpdateThingByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/datasets", wrapper.FindDatasetsForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/things/{uuid}/timeseries", wrapper.FindTimeSeriesForThing)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries", wrapper.FindTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries", wrapper.AddTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.DeleteTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.FindTimeSeriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/timeseries/{uuid}", wrapper.UpdateTimeseriesByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.DeleteDataFromTimeSeries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.QueryTimeseriesForData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/timeseries/{uuid}/data", wrapper.AddDataToTimeseries)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/tsquery", wrapper.FindTsdataByQuery)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users", wrapper.FindUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users", wrapper.AddUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/me", wrapper.Whoami)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}", wrapper.DeleteUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}", wrapper.FindUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}", wrapper.UpdateUserByUuid)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/policies", wrapper.FindPoliciesForUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v2/users/{uuid}/rate", wrapper.SetRequestRateForUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.FindTokensForUser)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v2/users/{uuid}/tokens", wrapper.AddNewTokenToUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v2/users/{uuid}/tokens/{token_uuid}", wrapper.DeleteTokenForUser)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.Swagger, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewSwaggerLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.SwaggerLoader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadSwaggerFromData(specData)
	if err != nil {
		return
	}
	return
}
